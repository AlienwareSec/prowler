{
  "Provider": "openstack",
  "CheckID": "compute_instance_metadata_sensitive_data",
  "CheckTitle": "Compute instance metadata does not contain sensitive data",
  "CheckType": [
    "Software and Configuration Checks/OpenStack Security Best Practices",
    "Software and Configuration Checks/Industry and Regulatory Standards"
  ],
  "ServiceName": "compute",
  "SubServiceName": "",
  "ResourceIdTemplate": "",
  "Severity": "critical",
  "ResourceType": "OpenStackInstance",
  "ResourceGroup": "compute",
  "Description": "**OpenStack compute instance metadata** is evaluated to detect **sensitive data** such as passwords, API keys, secrets, private keys, and database connection strings. Instance metadata is accessible via the metadata service (169.254.169.254) and can be queried by any process running inside the instance. Storing secrets in metadata exposes them to SSRF attacks, compromised applications, and unauthorized access.",
  "Risk": "Compute instance metadata containing sensitive data is vulnerable to:\n- **Confidentiality**: direct credential exposure via metadata service (169.254.169.254) accessible to any instance process\n- **Integrity**: stolen credentials enabling unauthorized modifications, data tampering, and privilege escalation\n- **Availability**: compromised accounts used for resource deletion, cryptomining, or ransomware attacks\nAttackers exploiting SSRF vulnerabilities, compromised applications, or insider threats can query the metadata service to extract passwords, API keys, database connection strings, and private keys. Hardcoded secrets in metadata bypass secrets management best practices and enable credential theft at scale.",
  "RelatedUrl": "",
  "AdditionalURLs": [
    "https://docs.openstack.org/nova/latest/user/metadata.html",
    "https://docs.openstack.org/security-guide/instance-management/instance-data.html",
    "https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url",
    "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
  ],
  "Remediation": {
    "Code": {
      "CLI": "# Remove sensitive metadata keys\nopenstack server unset --property <sensitive_key> <instance_id>\n\n# Verify metadata no longer contains secrets\nopenstack server show <instance_id> -f json | jq '.properties'\n\n# Use Barbican (OpenStack Key Manager) instead\nopenstack secret store --name db-password --payload \"$(openssl rand -base64 32)\"",
      "NativeIaC": "",
      "Other": "**Immediate remediation:**\n1. Identify instances with sensitive metadata: review check findings\n2. Extract credentials to secure storage:\n   - Use **Barbican** (OpenStack Key Manager) for secrets\n   - Use **HashiCorp Vault** for enterprise secrets management\n   - Use **cloud-init** with encrypted user data for bootstrap credentials\n3. Remove sensitive metadata: `openstack server unset --property <key> <instance_id>`\n4. Rotate exposed credentials immediately (assume compromised)\n5. Update applications to retrieve secrets from Barbican/Vault APIs\n\n**Long-term remediation:**\n1. Implement **secrets management** workflow:\n   - Store secrets in Barbican/Vault, not metadata\n   - Use **dynamic secrets** (short-lived, auto-rotated)\n   - Inject secrets at runtime via init containers or sidecars\n2. Use **cloud-init** for bootstrap credentials:\n   - Encrypt user data with instance keypair\n   - Retrieve secrets on first boot, store in instance credential cache\n   - Delete bootstrap secrets after initialization\n3. Implement **application-level secrets retrieval**:\n   - Use OpenStack SDK or Barbican API to fetch secrets\n   - Cache secrets in memory, not filesystem\n   - Rotate secrets periodically (e.g., every 90 days)\n4. Audit metadata usage:\n   - Review existing metadata keys for legitimate use cases\n   - Remove unused or legacy metadata keys\n   - Document approved metadata patterns in security baseline",
      "Terraform": "```hcl\n# Terraform: use Barbican for secrets instead of metadata\n\n# Store secret in Barbican\nresource \"openstack_keymanager_secret_v1\" \"db_password\" {\n  name                 = \"database-password\"\n  payload              = random_password.db_password.result\n  payload_content_type = \"text/plain\"\n  secret_type          = \"passphrase\"\n}\n\nresource \"random_password\" \"db_password\" {\n  length  = 32\n  special = true\n}\n\n# Instance WITHOUT sensitive data in metadata\nresource \"openstack_compute_instance_v2\" \"secure_instance\" {\n  name            = \"app-server\"\n  image_id        = var.image_id\n  flavor_id       = var.flavor_id\n  key_pair        = var.key_pair_name\n  security_groups = [\"app-sg\"]\n\n  # Safe metadata (non-sensitive labels only)\n  metadata = {\n    environment       = \"production\"\n    application       = \"web-app\"\n    cost_center       = \"engineering\"\n    barbican_secret_id = openstack_keymanager_secret_v1.db_password.secret_ref\n  }\n\n  network {\n    name = \"private-network\"\n  }\n\n  # Use cloud-init to retrieve secrets from Barbican\n  user_data = <<-EOF\n    #!/bin/bash\n    # Retrieve database password from Barbican\n    SECRET_REF=\"${openstack_keymanager_secret_v1.db_password.secret_ref}\"\n    DB_PASSWORD=$(openstack secret get \"$SECRET_REF\" --payload -f value)\n    \n    # Configure application with retrieved secret\n    echo \"DATABASE_URL=postgresql://user:$DB_PASSWORD@db-host/dbname\" > /etc/app/config.env\n    chmod 600 /etc/app/config.env\n  EOF\n}\n\n# ANTI-PATTERN: DO NOT DO THIS\n# resource \"openstack_compute_instance_v2\" \"insecure_instance\" {\n#   metadata = {\n#     db_password = \"hardcoded-secret-123\"  # ❌ NEVER store secrets in metadata\n#     api_key     = \"sk-1234567890abcdef\"   # ❌ Exposed via metadata service\n#   }\n# }\n```"
    },
    "Recommendation": {
      "Text": "Implement **secrets management best practices** for OpenStack:\n- **Never store secrets in metadata**; use Barbican, Vault, or external secrets management\n- Use **Barbican** (OpenStack Key Manager) for centralized secrets storage with RBAC\n- Implement **dynamic secrets** with automatic rotation (e.g., Vault database secrets engine)\n- Use **cloud-init** with encrypted user data for bootstrap credentials only\n- Retrieve secrets at **runtime** via APIs; never hardcode in metadata, environment variables, or config files\n- Implement **least privilege access** to Barbican secrets using Keystone policies\n- Enable **secrets audit logging** to track access and detect anomalous retrieval patterns\n- Use **envelope encryption** for secrets at rest (Barbican with HSM backend)\n- Implement **automatic secrets rotation** every 90 days or on security events\n- Scan **metadata, user data, and configuration management** tools for hardcoded secrets (git-secrets, TruffleHog, detect-secrets)\n- Use **break-glass procedures** for emergency secrets access (audit logged, time-limited)\n- Document **approved metadata usage**: tags, labels, non-sensitive configuration only\n- Train developers on **secure secrets handling** and consequences of credential exposure\n- Implement **CI/CD secrets scanning** to prevent secrets from being committed to infrastructure-as-code",
      "Url": "https://hub.prowler.com/check/compute_instance_metadata_sensitive_data"
    }
  },
  "Categories": [
    "secrets",
    "encryption"
  ],
  "DependsOn": [],
  "RelatedTo": [],
  "Notes": "This check uses regex pattern matching and may produce false positives (e.g., 'password_reset_url' without actual password). Review findings manually. Patterns detect: password, api_key, secret, private_key, connection_string. Does not validate actual credential format or entropy. Metadata is world-readable within instance via 169.254.169.254."
}
